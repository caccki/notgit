```yaml
프로그래밍 언어 > 프로그램> 어휘/구문 분석 > 변수,바인딩,영역,수명> 기억장소 할당
1.1.1 프로그래밍을 배워야 하는 이유: 알맞지 않은거 고르기
1.1.3 계산 전형 : 명령형, 적용형. 논리형, 객체지향
1.2 언어역사: 
1.3 언어 설계 기준: 

```

```yaml
# 추상화
추상화란: 프로그래머의 의도를 추상화하여 컴퓨터에게 전달
cpu 추상화: 연산자
기억장치 추상화: 변수
자료 추상화: 문자열,수,탐색트리
제어 추상화: 반복문,조건문,프로시저호출
---
정보의 양에 따른 추상화: 단위추상화>구조적추상화>기본적추상화
단위 추상화: 단위 프로그램 전체 정보에 관한 추상화
구조적 추상화: 프로그램의 구조에 대한 보다 전역적인 정보에 관한 추상화
기본적추상화: 국지적 정보에 관한 추상화


# 프로그래밍 언어론 배워야 하는이유
이유: 현재사용언어더잘이해,유용한프로그래밍구사능력증대,언어선택능력증대,새언어배우기쉽게해줌,언어설계쉽게해줌

# 1.1.3
명령형/절차형: 순차적 명령수행,변수사용(기억장치읽기),할당문사용(기억장치쓰기): c , fortran , Basic 
적용형/함수형: 함수에 적용하는 방식으로 프로그래밍,변수없음,할당문없음,반복연산은 재귀함수사용: lisp,scheme
논리형/선언적: 무엇을하려는지 선언하듯기술,반복문없음,선택문없음,기호논리학에기호를둠 : prolog
객체지향: 객체에기반을 둔언어, 객체란 실세계에 존재하는 모든 대상 :  smalltalk , java , c++ , ada

# 프로그래밍 언어의 형식정의
형식정의 필요성: 프로그래밍 언어의 명확한 사용체계를 알려줌,언어의모호함없애줌,예측가능
구문론: 표면적 구조 정의
의미론: 실행시 어떤 일이 일어나는가 기술


#1.2 프로그래밍 언어의 역사
기계어: cpu가 이해할수있는 일련의 2진법 명령 코드로 작성
어셈블리어: 기계어 코드를 대신할 기호나 연상기호 사용
50: fo,co,algo,lisp,apl
- 포트란: 최초의 고급언어,반복,배열,분기 개념 처음 도입
- 코볼: 레코드 구조도입(다양한자료 묶어서사용), 자료구조 부분과 실행부분 분리, 은행 대규모 회사 사무처리 목적으로 만듦
- aglol60: 블록개념,되부름,값 매개변수 호출 기법 도입
- lisp: 리스트구조와 함수의 응용을 기본으로 하여 인공지능 분야에 폭넓게 사용
- apl: 배열과 행렬을 포함하는 수학적 연산을 쉽게 프로그래밍 하기 위한 언어, 제어구조가 없음
60: basi,si
- pl/1 : 포트란,코볼,agol 장점 모음, 병행성, 예외처리기,기억장소 할당 기법 도입
- agol 68: 직교언어로 변경
- snobol: 최초의 문자열 처리 및 패턴 매칭 기능 언어
- simula: 시뮬레이션을 위해 설계. 클래스 객체 개념과 자료 추상화를 인식시키는데 크게 기여
- basic: 시분할 시스템을 위한 언어, 교육용 , 가정용으로 널리 보급
70: 씨팔스칼 , scheme(lisp일종)
- pascal: 작고 간결 효율, 교육 목적, 분리 컴파일 기능, 입출력 기능 효율화 , 문자열 조작, 고기능성
- c: 중급 프로그래밍 언어, 컴퓨터 구조에 접근 제공, 유닉스 체제 구현에 사용
80: ada,modula,ml,prolog,smalltalk,c++
- ada: 객체지향 언어 , 자료추상화, 타입메커니증, 병행처리, 예외처리기 등등 
- modula-2: 추상화, 부분적 동시처리, 내장형 시스템  , c , 파스칼 계승
- scheme : lisp 의 한 버전, 인공지능에 대한 관심으로 많이 이용
- prolog: 수학적 논리학 적용, 인공지능 분야에 쓰임
- smaltalk: 일관된 객체 지향 언어의 순수한 모범 케이스
- c++: 객체지향 , c언어를 확장
90: java
- java: 객체지향, 중간코드형테, jvm 위에서 수행, 이식성 좋음
2000: c# dart swift
- c#  : 마이크로소프트에서 개발 
- dart : 웹 개발
- swift: ios,osx 개발
```

```yaml
# 1.3 프로그래밍 언어 설계기준
효율성: 목적코드의효율성,번역의효율성,프로그래밍효율성, 얼마나 쉽고 빠르게 프로그램을 작성할수있는가(표현력)
일반성: 밀접한 관련 여러개념을 하나의 개념으로 결합 , c에서는 메모리를 포인터 개념으로 결합
확장성: 프로그래머가 언어 추가, (라이브러리 추가)
직교성: 구성요소가 결합하여 상호작용이나 문맥으로 인한 의도치 않은 부작용 발생 방지 ( return a 배열인경우 동작안됨)
획일성: 의미적, 형식적으로 유사한 것들은 그 유사성이 일관되게 유지되어야함 (do end , while end 등등..)
안정성: 오류를 줄이고, 쉽게발견  (자료형검사, 변수선언 등)
정확성: 정의에 의존 , 프로그래밍언어의 행위 예측
표현력: 프로그래밍 언어가 복잡한 과정이나 구조를 표현하는데 용이함 ( 되부름:recursion)
독립성: 하드웨어나 운영체제에 대해 독립적인 언어 (java)
일관성: 표준화된 특징과 개념을 갖도록 프로그래밍 언어 설계
부분성: 언어 일부분만 알아도 프로그래밍 가능하도록 설계
```

```yaml
#프로그래밍 언어의 구조
언어구조: 문자-어휘-구문
문자: 알파벳 , 내부적으로는 아스키코드로 변환
어휘: int, end, {} , 1,  5 , 프로그래밍 언어 문자로 구성된 단어=토큰=어휘토큰
구문: 함수명 , 인자 , 자료형+변수 , 프로그래밍 작성 규칙

# 번역기
단계: 어휘분석단계 -> 구문분석단계
어휘분석단계: 토큰으로 구분함
구문 분석단계: 토큰을 처리하여 구문 구조 결정함

# 용어정의
어휘(토큰): 프로그래밍 언어의 단어 , if , x , i , printf, (), ;
언어구성자: 하나이상의 어휘토큰을 이용한 구문적으로 허용된 프로그램의 일부구조, if ()then()else()
식별자: 변수, 자료형, 함수명 등에 이용되는 토큰 , x, int, prinf 등
미리정의된 식별자: 번역의 속도높이고 신뢰성 향상(scanf,print,if,for등) 
예약어: 미리정의된 식별자 중에 , 재정의 되지 않는 식별자 ( if , case , for 등) , 장점: 가독성향성, 컴파일 탐색시간단축, 오류 검색 단축, 단점: 예약어 관리 어려움, 예약어와 식별자의 중복피해야함
**문제** : 토큰(어휘)구조의 범주 : 예약어,식별자,특수기호,상수

```

```yaml
# 프로그래밍 언어 구문 형식정의
형식정의: 프로그래밍 언어를 이용해 정상적인 프로그램을 작성하는 규칙들의 집합, 공식이나 순서도를 이용해 표현됨



```

```yaml
# BNF ( BACJUS-NAUR form)
bnf: 구문에 대한 형식정의를 하는 방법, 생성 규칙들의 집합 , 왼쪽부분: 정의될 대상 , 오른쪽 부분: 그 대상에 대한 정의
비단말기호: <> 로 묶인 기호, 다시정의될 대상임을 의미
단말기호: 비단말기호가 아닌기호, 알파벳 문자집합, 예약어
메타기호: 특수기호들 ::=정의 , |: 택일 , | , <>
예: <identifier> ::| <letter> | <identifier><letter> | <identifier><digit>
<letter> ::= A|B|....X|Y|Z | a|b|...|z
<digit> ::= 0|1|2....8|9
문맥자유문법: 모든생성규칙에서 정의될 대상이 하나의 비단말 기호로만 구성 , <digit> ::= 0|1|...|9
문맥의존문법: 문맥에 따라 달라지는 문법 , 0b<digit> ::= 0b0 | 0b1 
```

```yaml
# EBNF ( 확장 bnf)
ebnf : 읽기쉽고 간결화된 bnf, 다양한 메타기호 사용
[x]: x가 나타나지 않거나 한번 나타남 = {x}01
{x}07 : x 가 0~7번까지 나타날수 있음 
(x|y) : 괄호안으로 한정하여 x,y 중 택일
'X' : 메타기호 x를 단말기호로 사용
예: <if-statement> ::= if<condition>then<statement>[else<statement>]
예: BNF
<expression> ::= <expression>+<expression>|
<expression>-<expression>|
<expression>*<expression>|
<expression>/<expression>
EBNF
<expression> ::= <expression>(+ | - | * | / )<expression>
예: 
<BNF-rule> ::= <left-part> '::=' <right-part>
<right-part> ::= <right-part-element>{'|'<right-part-element>}




```

```yaml
# 구문도표
구문도표: 구문에 대한 형식정의를 하는 또 다른 방법, 순서도와 비슷, ebnf와 대응관계
단말: 동그라미, 지시선
비단말: 네모, 지시선
 
```

```yaml
# 파스트리 와 모호성
파스트리: 주어진 BNF에 의해 어떤 표현이 생성될 수 있는지 확인 하기 위하여 작성하는 트리 , 단말노드의 나열이 주어진 BNF로 생성가능한 표현이 됨 , 주어진표현에대한 파스트리가 존재하면 그 표현은 주어진 BNF에 의해 작성된 표현으로 결정
추상구문트리: 파스트리의 본질적인 구조를 나타내는 트리 , 구문트리라고도함
구문의 모호성: 구문을 이용한 유도과정의 다양성
모호한 문법: 동일 표현에 대해 서로 다른 파스트리가 만들어지는 문법
모호성 제거 규칙: 비단말 기호와 구문규칙 추가 + 좌순환규칙을 사용(좌결합)
```

```yaml
# 프로그램의 신뢰성
프로그램의 신뢰성: 구문이 쉽게 분석될수 있어야함

# 신뢰성 위배사례
pl/1구문: A=B=C; , 다중할당 의도 , 실제: A=(B=C) 로해석됨; 의도대로하려면: A,B=C; 로 작성해야함 , pl/1 의 "="의미: 할당,등가비교 
사람의 실수: 철자오류
if문에서 else처리: 현수 else 문제 , BNF문법과 관계없이 언어자체가 가지는 모호성에 해당

```

```yaml
# 프로그래밍 언어 구현 기법
프로그래밍 구현 의미: 고급언어로 작성된 프로그램을 실제 컴퓨터에서 실행시킬수 있는 기계어로 만들어야함 , 컴파일기법이나 인터프리터 기법으로 구현 , 최근에는 두가지 합친 기법 사용
컴파일 기법: 고급어 -> 기계어로 번역 -> 프로그램 실행
컴파일 기법 번역기: 
1. 컴파일러: 고급언어(원시언어)를 저급언어(목적언어)로 만들어주는 번역기
2. 어셈블러: 어셈블리언어(원시언어)를 저급언어(목적언어)로 만들어주는 번역기
3. 링커: 재배치 형태의 기계어로 구성된 여러개의 프로그램을 묶어서 어느정도 실행가능한 하나의 기계어(로드모듈)로 번역
4. 로더: 로드모듈의 기계어 프로그램을 실행 가능한 기계어로 번역하여 주기억 장치에 적재
5. 프리프로세서: 원시언어와 목적언어가 모두 고급언어인 번역기
컴파일 기법 번역기 실행과정:
[고급언어 -컴파일러,어셈블러-> 목적모듈 -링커-> 로드모듈 -로더-> 기계어] , [입력자료 -기계어-> 실행결과]
인터프리트 기법: [ 고급언어프로그램 -인터프리터-> 실행결과 ] , 번역이아닌, 그 자체로 결과를 내놓음, 논리적 순서대로 문장을 실행 
인터프리트,컴파일 기법 공통점: 고급언어로 표현된 고수준의 프로그램을 읽어들임
인터프리터 vs 컴파일 : (논리적 순서대로 문장실행 vs 입력된 순서대로 문장처리) , (직접실행vs번역만함) ,(실행시마다 실행 시뮬레이션을 통해 코드 실행 vs 한번 번역된 코드는 다시 번역할 필요 없음, 반복처리/함수호출 많을때 효율적) , (사용자의 유연성을 중시 vs 컴퓨터의 실행시간 중시), 장점(추가기억장소 필요 없음 vs 많은 반복처리 프로그램 실행시 매우 효율적), 단점(실행시간김 vs 기억장치요구), 언어(lisp,snoblol4,apl,prolog vs fortran , agol, pl/i, pascal , cobol, c , ada ) , (유연성-바인딩을 실행시간까지 지연 vs 효율성-가능한 많은 바인딩이 번역하는 동안에 이루어지도록 설계)
중간코드 실행 기법: 컴파일 + 인터프리트 = 중간코드 실행 기법 , java-바이트코드사용-jvm 사용
```

```yaml
# 변수
변수: 값이 바뀔 수 있는 객체
변수속성: 이름,위치,형,범위,값,생명시간 ( 값은 동적으로 바인딩된다)
변수생성: 선언문 또는 묵시적 선언으로 생성
변수요소: 식별자(이름), 자료속성의 집합, 하나이상의 주소, 자료값
Barron표기법: (이름)-<속성들>-[주소: 값]
A = 30 : (A) - <정수> - [ff01 : 30]

# 기출문제
문제: 변수의 자료형은 변수의 기억장치의 크기와 관련되어있다.(o)
문제: 프로그래머에 의해 변수의 속성은 변경될수 있다 (o)
```

```yaml
# 바인딩
바인딩: 이름에 속성을 연결하는 과정 , 변수의 네가지 요소에 값을 확정하는 것 , 프로그램 기본단위의 속성을 결정짓는다
바인딩 시간의 중요성: 효율성(컴파일러언어: fortran,agol,cobol,c) , 유연성(인터프리터 언어: snobol4,apl,lisp)
바인딩 시간: 바인딩이 일어나는 시간
번역시간(정적 바인딩, 정적형검사): (컴파일시간, 링크시간 , 로드 시간) , 변수의 형 ,   자료구조의 형과 크기, 레코드의 각 항목들의 형 등을 확정 , 컴파일러 언어는 대부분 정적 바인딩한다 
실행시간(동적 바인딩 , 동적형검사): 변수의 값을 확정(a = 1), 자료구조(배열)에 기억장소(주소)를 할당
속성: 프로그램에 나타나는 변수, 프로시저, 문 등의 실체들마다 갖게되는 어떤 성질

언어의 구현시간: 정수의 자릿수, 실수의 유효숫자 개수 , 수의 기계내에서의 표현법
언어의 정의시간: 혼합형 연산이 허용되는 경우, 연산해야될 두 피연산자의 형에 따라 어떤 형의 연산을 해야 되는지를 확정
바인딩 시간의 예 : Q = T+30
실행시간 - T 의 값 변동
번역시간 - T의 자료형, 기억장소 크기 확정
언어의 구현시간 - 30이 실제 기계에서 표현되는 방법 ( 2진수를 쓰겠다 등등 정의)
언어의 정의시간 - 10진법 상수 30을 의미, + 가 덧셈연산자임을 확정 

```

```yaml
# 선언과 할당 , 식과 제어문 ( 기출문제 거의 없다 )
선언: 실행시 사용될 자료의 속성을 컴파일러등 에게 알려주는 것, 바인딩을 제공하는 중요한 방법
선언예시: int[] a = new int[30] , 자료형: 1차원배열 , 원소의 갯수:30 , 첨자의 범위: 0~29정수, 각 원소의 자료형: 정수형 , 참조할 배열 이름: A
선언문의 목적: 주기억장치 사용과 접근방법의 효율성, 주기억장치 경영의 효율성, 정적 형 검사가능

# 선언문의 목적
주기억 장치 사용과 접근방법의 효율성: 프로그램 실행 동안에 변하지 않는 자료구조의 속성들을 한정, 자료 구조에 접근하기 위한 계산을 컴파일러가 최적화함, 주기억 장치의 절약 및 프로그램 실행 시간의 절약
주기억 장치 경영의 효율성: 자료구조의 크기, 생성시기, 소멸시기등을 번역시간에 알게됨, 보다 효율적인 기억장소 배당기법을 알게됨
정적 형 검사 가능: 컴파일 시 혼합형 연산에 대한 목적 코드를 형 고정 연산으로 변환, 잘못사용한 자료형등을 번역시간에 찾아낼수 있어, 프로그램의 신뢰성을 높일 수 있음
# 할당문
할당문: 변수의 내용을 변경할수 있는 연산, 프로그램에서 가장 일방적으로 나타나는 연산

# 할당문의 종류
단순할당문 : A = B , 목적 변수 = 할당연산자
다중목적변수 할당문: A,B,C = 0 
조건 목적변수 할당문 : flag ? N:M = 0
복합 할당 연산자: S += T
단항 할당 연산자: S++
식으로서의 할당문: 할당문은 목적변수에 할당된 값과 동일한 결과를 생성, 할당문 자체를 식으로 혹은 다른식에 포함된 피연산자로 사용 가능 , 식 부작용 유발가능 -> 가동성 저하 ex) s=t(할당) , s==t(논리값) 둘다 가능한 문장 
혼합형 할당문: 할당문의 양쪽 자료형이 서로 다른 경우를 의미 , w = int/float , 묵시적 형변환 적용 , c/c++ 자유로운 형변환 가능 , java 확대 형 변환인 경우에만 허용
# 상수
상수:  프로그램 수행중 변하지 않음, 상수에 어떤 값을 재할당 하려는 경우 컴파일러가 쉽게 인식

# 변수초기화
변수초기화: int m = 10 , int[] s = new int [7],  int t[] = {0,1,2,3,4,5,6}

# 표현식
표현식: 하나이상의 피연사자를 가지고 자료값의 계산을 기술하는것 , 구성: 피연산자(상수,변수),연산자,함수호출
식의 평가: 평가순서: 연산자 우선순위, 좌결합법칙(APL등 일부 우결합법칙)
논리조건: 일반적: 두개의 피연산자를 우선 평가한후 연산자 적용, 논리연산자: 논리조건에 따라 다름, n=0 or m/n<1 이경우 좌측만 연산하면 오류 없는데 , 우측까지 연산하는 경우 오류발생, 언어에 따라 좌측만 계산해서 참이면 그냥 넘어가기도 하고, 우측까지 계산해서 오류를 발생시키기도 함
단락회로 평가기법: 컴파일러상의 불일치를 제거하기 위함. A and B => if a then b 식으로 풀어써서 오류 제거
조건문: 조건에 따라 실행되는 부분이 달라질때 사용 , if(조건문)X1,X2 , if(수식)x1,x2,x3
내포된 if 문: if else else ...
switch 문: switch(정수식) case case ... 스위치문은 정수식 사용 , break 문 사용
반복문: 0번이상 반복하여 실행시키는 문장
반복문 제어: goto 문 , exit 문 , break문 반복문 밖으로 이동 , continue문 반복문의 처음으로 이동
while문: while(조건식) 문장  
until문 : repeat<문장>until<조건식 : 참이될때 까지>
do-while문: do<문장>while<조건식: 거짓이 될때까지>
for문, 제어변수반복문: for(<식1>;<식2>;<식3>)(문장)

```

```yaml
#자료형과 선언
자료형: 객체의 집합 + 연산의 집합
내장된자료형: 정수형, 실수형, 문자형, 논리형
형시스템: 자료형을 정의하고 변수를 특정된 자료형으로 선언해주는 도구 | 유의사항: 변수의 많은 특성이 선언문에서 확정됨, 선언된 형 이름과 변수의 선언은 이러한 일반적인 특성을 가짐 | 특징: 형이름과 변수 선언이 갖는 특성을 변화시킬수 있음, 명세부를 실질적인 구현부분에서 분리시킴, 서로다른 특성을 갖는 객체를 분명하게 구별함(컴파일러가 수행)
강 자료형: 컴파일시간에 확정되는 프로그래밍 언어, 단점: 미리결정해야함 장점: 신뢰성,유지보수성,가독성 향상
자료형의 구성원: 객체,요소,값 으로 불림 | 자료형의 구성원이 자료형 영역을 구성함| 리터럴: 프로그래머가 작성한 구성원
스칼라형(단순형,기본형  ): 정수형, 실수형, 논리형 , 문자형 등 ( 단순한 상수값)
구조형: 배열 , 레코드 (자료의 집합)

# 단순형
수치형: 정수 또는 실수값을 표현 연산: 덧셈, 곱셈등 , 다형성: 정수+정수, 실수+실수 , 정수+실수? 규칙도표의존, 연산결과형에 의존
논리형: 참/거짓 두개의 객체로 구성
문자형: 문자열 연산 수행후 문자열의 길이는 번역시간에 결정될 수 없음, 프로그래밍언어구형의 어려움 , strint st1 = 'string' , char st1[] = {'s','t','r''i''n''g'}
열거형(단순형의일종): 객체의영역: 리스트로 정해줌 , 연산: 동등및 순서관계 연산, 할당 연산
열거형의예: 
enum size {default,plus,minus} 
= const int default = 0 ; const int plus =1 ; const int munus = 2;
식별자를 함께선언하여, 별도의 자료형이 될수있음
enum size {default,plus,minus} 

# 구조형
배열과레코드: 여러자료를 묶어서 하나의 단위로 처리할 수 있는 구조형 ( 집합체 또는 복합형)
배열: 동질형자료
레코드: 이질형자료

# 배열
배열: 이름,차원,원소형,첨자 집합의 형과 범위 등으로 특징됨,이름+첨자(인덱스)
배열이름[첨자_리스트] -> 원소 
배열의 자료형: 원소형, 첨자형
첨자형: 정수의 부분범위가 일반적, (서수형첨자: pascal,ada등)
첨자범위: 차원별로 하한(lb), 상한(ub), 크기: ub-lb+1 , 경계값으로 정의 , 신뢰성확보
첨자형 바인딩: 보통정적 바인딩, 첨자번위는 때때로 동적 바인딩
정적배열: 첨자 범위가 정적으로 바인딩, 기억장소 할당이 정적으로 이뤄짐
차원: 대부분의 프로그래밍 언어는 배열 차원을 제한하지 않음
명세표: 배열이름 , 원소의 형, 원소길이, 시작주소, 차원수 , 첨자하한, 첨자 상한

배열 저장: 행우선 저장, 열우선저장, 배열의 초기화
배열 초기화: int s[] = { 3, 14, 2, 5} , 배열의 기억장소가 할당되는 시간에 배열을 초기화하는 수단 제공
문자배열: 문자 스트링은 char 배열로 구현, 스트링 상수로 초기화, 모든 스트링은 ₩0 로 끝남, 시스템은 스트링 상수에 널 문자를 묵시적으로 제공

# 연상배열
연상배열: 키-값
배열,연상배열 차이점: 연상배열은 사용자가 정의한 키값으로 첨자를 대신한다
펄의 연상배열(해시): 구현과정에서 원소들이 해시함수를 통해 입력-출력 됨
입력(임의길이를 갖는 데이터)-출력(고정된 작은 크기 데이터)


# 레코드
레코드: 원소를 식별자로 구별하는 이질형 자료의 집합체 , 레코드의 특정원소는 두가지 수준의 구문기법에 의해 참조됨


# 포인터 자료형
포인터: 어떤 객체에 대한 기억장치 주소 참조 방법
포인터변수: 객체를 참조하기 위한 기억장치 주소를 값으로 취하는 식별자
힙: 동적으로 객체가 배당되는 기억장소 영역
힙 변수: 힙에 해당되는 변수
포인터 특징: 프로그래밍 언어의 작성력 향상, 구조형이나 스칼라형이 아님, 단지 참조하는거
- 주소가 어셈블리 언어에서 사용되는 것처럼 사용가능
- 포인터 산술연산 가능 => 프로그램의 유연성 높음 => 허상 참조나 분실된 동적 변수 문제들 발생 
- 역참조 연산자 : *
- 변수의 주소를 생성하는 연산자 : &
현수참조: 포인터가 이미 힙에 반납된 기억장소를 지시하는 경우를 말한다

# 자료형 변환
형검사: 정적형검사:컴파일시간 , 동적 형검사:실행시간
형변환: 묵시적형변환: 컴파일러에서 자동으로 , 명시적형변환: 프로그래머가 변경,cast명령문
```
```yaml
# 영역과 수명
영역: 프로그램에서 사용되는 식별자가 의미를 가질수 있는 범위 
블록: 내부에서 식별자를 선언하여 새로운 프로그램 환경을 설정할 수 있는 특별한 언어구조를 제공
begin-end , { }, 등으로 불록 설정
선언문의 처리효과: 번역시간: 선언문을 만날 때 , 실행시간: 선언문이 있는 블록이 활성화 될때 , 변수는 블록이 실행되는 동안에만 의미 있는 값을 지님
변수의 수명: 변수에 의미있는 기억장소가 할당되어 있는 기간
c언어: 단일함수에 단일 블록으로 구성됨, 스택기반 기억장소 할당 방법

# 정적영역과 동적 영역
정적영역규칙: 번역시간에 결정, 일반적인 컴파일러 언어 , 프로그램 문맥으로 해결 
동적영역규칙: 실행시간에 결정, 식별자 영역을 작성된 프로그램 문맥이 아닌 실행되고 있는 순서로 해결 , 비지역변수에 대한 바인딩이 호출순서에 따라 결정
LISP 초기 버전, APL, snobol4

# 정적 영역
지역변수: 블록에서 선언된 변수와 형식매개변수
비지역/전역변수: 블록을 내포하고 있는 외부 블록에서 선언된 변수
자유변수: 현블록에 정의되지 않은 변수, 바깥쪽 블록을 조사한다

영역구멍: 가리워짐

# c,c++,java 
특징: agol과 같은 개념의 블록 중심 언어 , 복합문을 위해서 시작과 마침을 표시하는 기호로 {} 사용
c: 외부영역: 함수전체를 영역으로 하는부분, 전역영역임 
c++,java: 변수 정의가 함수의 어느 부분에서도 나타날 수 있음


# 변수의 수명
포트란: 프로그램의 수명과 변수 수명 동일
agol: 영역:블록에 의존 
c: 자동할당: 블록의존, 정적할당: 프로그램의존, 프로그래머 지정 할당: 프로그래머가 지정함(malloc())

# 환경
환경: 지역단위로 묶여진 장소와 관련된 모든 식별자를 정의, 지역변수 , 진입점 ,비지역 변수에 접근하기 위한 정보 및 그 블록에서 선언된 프로시저와 레이블을 포함 , 실행시간 동안 각 블록은 하나의 새로운 환경을 가짐, 선언문은 새로운 환경을 만들고 할당문은 새로운 값의 저장을 의미

# 영역과 수명
정적영역규칙 : 포트란, agol, pascal
수명: 언어별로 다름
동적수명: 프로그래머에게 기억장소의 수명 제어권을 부여 , pascal ,c++, java / new 연산에 의해 동적으로 생성, 기억장소는 레코드가 생성된 블록을 벗어나도 프로그램에 의해 기억장소로 부터 해제될 때까지 계속 존재함
기억장소 회수 방법:
1. 정적할당 회수: 기억장소를 실행시간 내내 할당하다가 주 프로그램 종료시 회수  , 예 : fortran
2. 명시적 해제: 할당된 기억장소를 해제하는 명시적 명령어를 제공
3. 쓰레기 수집: 프로그램에서 더 이상 참조가 없더라도 계속 기억장소에 존재
?. 동적할당 회수: 14년도 52번 문제

# c언어에서의 영역과수명
파일범위: include소스파일전체 , 전역변수 , extern 확장 전역변수 , static형은 확장불가능
함수범위: 함수가 선언된 부분
블록범위: { } 로 묶인부분


# 정적/동적 기억장소 할당 기법
정적(번역시간)할당: 배열에 할당된 기억장소의 크기나 위치등이 정적으로 결정되는 경우 , 배열 접근 코드를 효율적으로 작성가능
조건-모든배열은 확정된 고정크기로 선언되어야 함, 부프로그램은  재귀호출이 허용되지 않아야함

동적(실행시간)할당: 인터프리터언어의 경우 동적 기억장소 할당 필요, 실행시간 길어짐 , 예: snobol , aol ,lisp
, 변수에 대한 기억장소 할당을 동적으로 요구함, 프로그램 실행시 변수에 대한 기억장소의 크기가 수시로 변하지 않기 때문에 효율적인 접근 코드 작성 가능, 스택을 사용하여 동적 기억장소 할당 가능

정적+동적 할당: pl/1 정적+동적 , 변수는 정적으로 할당, 필요한 경우 특정 선언문을 통해 동적 기억 장소 할당 기법 사용 , atomatic 선언문: 부프로그램의 진입에서 생성되었다가 반환될때 회수 , controlled 선언문: 프로그램 실행시간에 allocate로 자료생성-free로 회수

# 6.2 단위 프로그램
단위프로그램: 모듈 , 블록
활성화 상태: 실행부터 종료까지
단위 활성화: 실행시간에 프로그램이 표현된 상태 
단위활성화 = 코드부 + 활성화 레코드(반환주소,동적링크,등등)
코드부는 실행동안 하나만 존재, 활성화 레코드는 호출시 새로생성 되며 코드부와 활성화 레코드는 동적바인딩
- 코드부: 프로그램의 명령어로 구성 , 고정크기 , 프로그램실행동안 변하지 않음
- 활성화레코드: 프로그램 실행에 필요한 정보가짐(반환주소,매개변수,지역변수,함수등,정적링크,동적링크 not 전역변수), 프로그램실행동안 변함
- 반환주소: 호출한 단위 활성화로 되돌아갈 주소 , 반환주소 = 코드부에대한 포인터+차감거리
- 동적링크: 호출한 활성화 레코드를 가리키는 주소값을 저장하는 포인터
- 동적체인: 활성화레코드부터 동적링크의 연결



참조환경: 지역변수, 비지역변수
- 컴파일할때 피연산자나 자료구조의 주소 결정할때 사용 (워크북60p)
- 명령문에서 접근할수 있는 변수들의 집합 (워크북60p)

- 지역변수: 자신의 활성화 레코드에 할당
- 비지역변수: 외부의 활성화 레코드에 할당



#정적 기억장소 할당
정적변수: 번역시간할당 , 크기고정
- 수명: 프로그램 실행시간 전체(정적변수)
- 활성화 레코드 : 실행전에 할당하여 실행이 종료될 때까지 유지됨
- 변수의 영역: 변수가 선언된 단위 프로그램에 국한

정적할당단점: 활성화 되지 않을 수도 있는 활성화 레코드 역시 주기억장소를 항상 차지함, 프로그래밍 언어에 대한 유연성이 적음
포트란: 주프로그램+부프로그램
- common: 전역변수를 선언함


# 6.4 스택기반동적 기억장소 할당
동적기억장소할당: 실행중 할당, 인터프리터언어에 사용, 상당수 컴파일러 언어에 사용, 블록기반 언어(agol60의 영향을 받아 설계된 언언 , 변수들의 영역제한, 단위프로그램개념도입 , agol,ada,pascal등)
블록기반 언어의 단위 프로그램 : 블록, 부프로그램
- 블록: 특정 블록의 실행차례가 되었을 때 활성화 됨, 지역선언문을 가지며 새로운 실행 환경을 정의하기 위한 단위
- 부프로그램: 호출문에 의해 호출되었을때 활성화 됨, 변수영역이 블록에서의 변수 영역과 동일한 규칙을 따름


# 정리
영역: 프로그램에서 사용되는 식별자가 의미를 가질수 있는 범위 
블록: 내부에서 식별자를 선언하여 새로운 프로그램 환경을 설정할 수 있는 특별한 언어구조를 제공

정적영역: 블록단위
- 지역/비지역/자유변수
- 변칙현상/영역구멍/가시성
동적영역: 실행순서 단위
동적영역규칙: 실행순서로 검사
정적영역규칙: 블록단위로  검사

정적기억장소할당: 배열에 할당된 기억장소의 크기나 위치등이 정적으로 결정되는 경우 , 배열 접근 코드를 효율적으로 작성가능
조건-모든배열은 확정된 고정크기로 선언되어야 함, 부프로그램은  재귀호출이 허용되지 않아야함
동적기억장소할당: 인터프리터언어 , 실행시간 길어짐 , snobol , aol ,lisp
, 변수 기억장소 동적 할당, 프로그램 실행시 변수에 대한 기억장소의 크기가 수시로 변하지 않기 때문에 효율적인 접근 코드 작성 가능, 스택사용가능(스택기반동적기억장소할당)
정적변수:
준정적변수: 정적바인딩(활성레코드 크기, 변수 차감거리) + 동적바인딩 (실제주소, 단위프로그램활성화될때 지역변수의 생성 ) 
- 재귀호출가능하게함, 스택기반의 기억장소 할당, 효율적인 주기억장소 활용가능
- 동적링크: 호출한 활성화 레코드를 가리키는 주소값을 저장하는 포인터
- 동적체인: 활성화레코드부터 동적링크의 연결
- 동적내포관계: 단위프로그램의 호출관계를 의미
동적변수: 동적 ( 생성-회수,  활성화 크기가 동적으로 변하는 경우) , { pascal: new, c: malloc}
- 힙동적배열(유연성배열): 프로그램이 실행중에 할당되는 자료들에 맞춰서 크기를 조절할 수 있는 배열
- 프로그램에서 변수 시점을 정해주는 변수: 실행문으로 자료 구조를 생성하여 확장가능
준동적변수:  동적바인딩(활성화 시점에 활성화레코드크기 결정, 한번결정되면 종결까지 크기 고정) + 스택변수
정적링크:
- 정적내포관계: 정적영역에 따른 비지역변수의 영역관계를 의미



4. 비지역변수의 참조방법
- 정적체인 사용기법: 모든 활성화 레코드에 정적링크를 할당, 비지역변수에 대한 참조시 정적체인을 따라 검색해서 먼저 발견된 변수를 참조, 검색시간이 많이 필요하기 때문에 실제로 사용하지는 않음
- 정적링크: 작성된 프로그램의 정적 내포관계에 있는 활성화 레코드를 가리키는 포인터
- 정적체인: 활성화 레코드로부터 연결된 정적 링크의 순서, 활성화된 레코드로부터 정적링크를 추적한 연결
- 디스플레이 사용 기법: 비지역변수들의 자료값에 대한 참조시간을 줄이기 위한 구현기법, 정적링크대신에 실행시간 어느 시점에서나 정적 체인 관계를 디스플레이라고 부르는 1차원 가변 배열을 사용하여 유지, 단위 프로그램의 호출과 반환 횟수에 비하여 비지역변수의 사용이 상대적으로 증가할 경우 좋은 방법 { 활성화 레코드가 할당되거나 회수될 때마다 디스플레이 내용을 변경시키는 일을 수행해야함}



# 부 프로그램(프로시저)의 개요
부프로그램: 모듈화 가능한 프로그램 { 함수 , 서브루틴 }
- 함수:  이름으로 하나의 값 반환, 변수처럼 하나의 원소로 사용 , 값반환은 함수이름에 하거나, return문 사용
- 서브루틴: 서브루틴 이름으로 값을 반환하지 않음, 결과값을 하나이상의 매개변수에 할당하거나 자신의 환경을 변환, 혹은 둘 다 수행함으로써 주어진 목적을 완성하는 프로시저

부프로그램 특성: 각 프로시저는 단일 진입점을 가짐 , 프로그램 실행 - 호촐된 프로그램 실행/종료 - 프로그램 종료
프로시져: 명령형 프로그래밍 언어에 국한된 용어  , 함수와 서브루틴을 구별하지 않는 부 프로그램을 의미
프로시져구성요소: 프로시저이름,매개변수 리스트 ,실행환경(선언부), 몸체

# 매개변수 종류
형식매개변수: 부 프로그램이 실행되는 동안에 호출자가 보내준 식 또는 다른 이름을 대신하여 그 프로그램에서 사용되는 이름, 프로시저의 정의에서 선언되어 일반적으로 지역 변수 역할을 함
실 매개변수: 원래의 식 또는 이름, 상수나 식의 사용 여부는 프로그래밍 언어에 따라 다름
# 매개변수 전달 기법
참조호출: 실매개변수의 주소를 대응되는 형식매개변수에게 보내는 방법 {포트란, pl/1}
- 호출프로그램의 사용된 실 매개변수가 식인지 판가름 하여 식이면 그 값을 계산해서 임시 기억장소에 저장 , 필요한 경우 실 매개변수에 해당되는 주소를 계산, 실 매개변수를 참조할 수 있도록 그 주소를 호출된 프로시저
값호출(값전달): 실매개변수 -> 형식매개 변수 , 형식매개변수에 해당되는 기억장소를 별도로 유지하는 방법 , 실매개변수 값이 변하지 않음 {c,pascal}
결과호출(결과전달): 형식매개변수-> 실매개변수, 호출된 프로시저가 값을 반환하는 한 가지 방법
이름호출: 형식매개변수가 사용된 모든 자리에 실 매개변수의 이름을 그대로 복사한 것처럼 간주하여 사용하는 방법, algol60


# 부작용, 별명, 연산자 다형성
1. goto문, 포인터
- 가독성 저해, 부작용 발생
2. 부작용 ,별명
- 변수의 값 헷갈림
3. 연산자 다형성
- 중복개념때문에 난해, 일반적으로는 가독성 높여줌


# 부작용
국제표준: 실행에서 야기되는 간접적 결과들의미
일반적: 지역변수이외에 변수값을 변화시키는것으로 국한,
비지역변수의 접근 또는 매개변수의 전달기법들 중 참조호출과 이름 호출에서 대표적으로 발생
블록중심 언어에서 현재 실행중인 블록을 내포하고있는 블록의 비지역 변수를 사용할 때 나타냄
# 별명
동일한 기억장소를 공유하는 다른 이름
# 연산자다형성
중복정의: 한개체가 두가지 이상의 개념으로 사용되는것
연산자 중복정의: 정수+정수 / 실수 + 정수 등등, 사용자정의도 가능



# 추상자료형의 개요
프로시저추상화: 어떻게 수행되는가를 기술하지 않고 무엇이 수행되는가를 묘사
자료추상화: 자료형의 표현과 그에 관련된 연산들을 함께 묶어 캡슐화
추상자료형(ADT): 자료와 연선을 함께 선언한 자료형, 정보은닉개념을 도입해 쉽게 읽고 유지보수 가능한 자료형
- 수정용이성, 재사용성, 보안성
캡슐화: 자료형 보호 기법, 사용자는 윈도우를 통한 사용만 허락됨
공용부: 윈도우를 통해서 외부에 알려주는 부분
전용부: 윈도우 캡슐화를 통해 보호하는 부분
공개한다: 공개하는 행위
도입한다: 다른 모듈프로그램에서 공개된 객체들을 사용할 수 있도록 연결하는 행위

추상자료형의형태: 
structure: 자료형의 이름, 각종선언문, 자료형의 표현, 일련의 프로시저문
폐쇄영역: 구조에서 정의된 이름들ㅇ르 명시적으로 공개하지 않는 한 외부에서 사용할 수 없는 영역


# c++ 의 추상자료형
클래스: 변수를 선언할 수 있는 자료형임
클래스: 데이터멤버 , 멤버함수 , 생성자 , 소멸자 / {공용절,전용절,보호절}
데이터멤버: 클래스에서 정의된 자료
멤버 함수: 클래스에서 정의된 함수
인스턴스: 객체, 스택변수이지만 클래스는 힙 변수적 데이터 멤버를 가질수 있음, 수명은 인스턴스화 한 선언문의 영역에서 벗어날 때 끝남, 한 클래스의 모든 인스턴스는 멤버함수 집합 하나만 공유하지만 각 인스턴스는 각자 자신의 데이터 멤버 집합을 가짐
생성자: 인스턴스가 생성될 때 묵시적으로 호출됨, 클래스와 같은이름 , 하나의 클래스에 하나이상의 생성자 가질수 있음, new 연산자를 사용하여 인스턴스의 일부를 힙에 할당가능
소멸자: 인스턴스의 수명이 끝났을때 묵시적 호출, '~'표 붙여서 사용, new 연산자로 생성시킨 힙 변수 데이터 멤버가 포함된 경우 소멸자는 힙 변수 데이터 멤버의 기억장소를 회수하기 위하여 delete연산자를 포함할 수 있음

매개변수 추상자료형: 좀 더 편리하게 추상자료형을 이용할 수 있음
틀 매개변수: 클래스 틀을 만들때 스택의 원소형을 매개변수로 사용할 수 있음


# java의 추상자료형
- 모든 사용자 정의 자료형이 클래스임
- 모든 객체는 힙에 할당되고 참조형 변수를 통하여 접근됨
- 부 프로그램은 오직 클래스에서만 정의됨
- private,public,protected는 메소드와 변수정의에 첨가되는 접근 수정자임
패키지: 클래스의 상위 구조, 패키지는 한개이상의 클래스 정의 가지며, 패키지 내에서 각 클래스는 다른 클래스의 부분 프렌드임,접근수정자가 없는 개체들은 패키지 영역을 가짐, java는 명백한 프렌드 선언을 가질 필요성이 적으므로 c++의 프렌드 함수 또는 프렌드 클래스를 포함하지 않음, 가끔 라이브러리를 포함하는 패키지는 계층구조로 정의됨
부분프렌드: public선언,protected선언, 또는 접근 수정자가 생략되었으면 패키지 내의 클래스에서 정의된 개체는 패키지 내의 모든 클래스에서 가시적( 즉, private 선언이 아닌 한 가시적임  ), 
소멸자부재: java는 묵시적인 쓰레기 수집 사용, 힙에 있는 사용하지 않는 객체장소는 쓰레기 수집을  통해 재새용, 즉 필요성이 없어 java에는 소멸자가 없음
```
```yaml

```
```yaml

```
```yaml

```
```yaml


```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml
명령문에서 접근할수있는 변수들의 집합 = 활성화레코드 x , 참조환경 o

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml
5
```

