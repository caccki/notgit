```yaml
# 1강 객체지향 언어의 개념
추상화: 실세계 특성중 핵심요소를 모델로 표현
객체: 속성(데이터) + 메소드(함수)
캡슐화: 내부속성-정보은닉, 외부속성-인터페이스,공개속성
- 장점: 유지보수,재사용성

클래스: 객체의 설계도
상속: 상위(기초)클래스-하위(파생)클래스 상속가능
다형성: 동일한 연산, 메소드가 대상에 따라 다르게 동작하는것
바인딩: 이름과 실체가 연결되는것
동적바인딩: 프로그램 실행과정에 바인딩이 일어나는것

# c++언어
c++언어: 1979년 벨 연구소에서 c언어를확장하여 만든 언어 , { 클래스, 상속, 다형성, 동적바인딩, 템플릿, 예외처리 등 추가}
c++ 표준화기구 (ISO): c++ 표준화 작업 수행
```

```yaml
# c++ 프로그램의 기본 구조
소스프로그램 파일: { .cpp , .cxx, .c }
헤더파일 : 클래스, 함수의 원형, 매크로, 전역변수 , 상수 등 공통선언부 , { 확장자: .h }


# 용어정리
선행처리: 소스프로그램 -> 선행처리 -> 가공된 소스프로그램 -> 번역
선행처리 지시어: 샵으로 시작, 한행에 한문장
선행처리 예: 조건부 컴파일
대표적인 선행처리: 헤더파일 삽입, 조건부 컴파일, 매크로 확장 등
헤더파일 삽입(사용자가 만든 헤더파일): #include "a.h" 
헤더파일 삽입(컴파일러가 기본 제공하는 파일) : #include <iostream> 
명칭공간: 명칭공간::명칭 , mynsp1::n
- 전역명칭공간: 기본명칭공간 , ::n , n ( 가까운 명칭공간 )
- std 명칭공간: 표준 c++라이브러리의 명칭들이 정의되어 있는 명칭공간 , std::cout
- using namespace: 특정 명칭 공간을 기본 명칭공간에 포함시키기 위한 구문
ex) using namespace std;

# 스트림 입출력
cout 객체: 표준 출력 스트림 객체,데이터를 문자열로 변환하여 출력함, 출력연산자: <<
cin 객체: 표준입력 스트림 객체, 문자열을 입력 변수의 자료형의 값으로 변환하여 입력함. 입력 연산자 : >>

# 기본 자료형
정수: 고정소수점 방식의 숫자표현, char(1byte) , short(2byte) , int , long(4byte)
10진수: nnn
8진수: Onnn
16진수: Oxnnn

# 정수상수
int형 상수: 123
unsigned int 형 상수: 123u
long형 상수: 123l
unsigned long 형 상수: 123ul

# 문자상수
아스키코드 10지수 표현 : 'A' = '65'
아스키코드의 8진수 표현 : 'A' = '\101' 
아스키코드의 16진수 표현: 'A' = '\x41' 


# 실수를 표현하는 자료형 
실수: 부동소수점 방식 , 소수점이있거나 e가 있으면 실수형 상수임
float(4byte) : 부호 1비트, 지수부 8비트, 가수부 23비트 ( 1.2x10^-38 ~ 3.4x10^38 )
double(8byte) : 부호 1비트, 지수부 11비트, 가수부 52비트 ( 2.2x10^-308 ~ 1.8x10^308)
1200 = 1200. = 1200.0 = 12e2 = 1.2e+3 = 1200.0f = 12e2f (f가 붙으면 float 아니면 double)

# 변수와 상수
변수: 프로그램이 실행됭안 기억해야하는 값을 저장하는 메모리 영역, 변수에는 이름 지정, 미리 선언해야함
변수 선언 위치: 함수 내부(지역변수), 함수 외부(전역변수)
변수 선언 형식: int a,b,c; / int a = 0; 
상수: 정해진 값은 변경할 수 없음. 
상수 선언 형식: const int c=10; 


# 자료형 변환
자동적 형 변환 개요: 연산시 자동으로 형 변환됨(넓은범위로) , 여러개의 연산으로 구성된 수식에서 자동 형 변환은 연산자 단위로 이뤄짐 , 대입연산자는 값을 저장할 변수의 자료형으로 자동형 변환됨 , 오차오버플로우 주의해야함

# 형변환 연산자
dynamic_cast: 기초 클래스와 파생 클래스 간의 포인터 또는 참조 형 변환이 프로그램 실행 중에 일어나도록 지시함.
static_cast: 실행 중에 형 검사를 하지 않으며, 컴파일 할 때 수식에 지정된 그대로 변환함.
reinterpret_cast: 포인터를 다른 자료형의 포인터나 정수 자료형으로 , 또는 그 역으로 변환함
const_cast: const 지정을 일시 해제함

# 연산자
산술연산자(2항연산자): 사칙연산자, 나머지 연산자
산술연산자(단항연산자): 증감연산자, 부호연산자
대입연산자: a=0 , a=b=0 , a=b=1.5
복합대입연산자: += , >>= , %= 등
관계연산자: > , ==  , != , >= 등
논리연산자: 논리합 || , 논리곱 && , 부정 ! { 좌항 우항 모두 검사하지 않고 한쪽이 결정되면 더이상 검사하지 않는다}
비트단위논리연산자: 논리합 | , 논리곱 & , 배타적 논리합 ^ , 부정 ~
비트이동연산자: 부호없는경우: 0이 붙는다 , 부호 있는 경우: 1이 붙는다
조건연산자: 조건? 값1 : 값2 , true이면 값1 , false면 값2

# 프로그램 개발 도구의 활용
빌드: 소스프로그램 파일 - < 컴파일러 > -> 목적프로그램 파일 -> <링커> -> 실행프로그램 파일 
통합개발환경(IDE): 에디터, 컴파일러, 링커 , 디버깅 도구 등
프로그램 생성과정: 프로젝트 생성-> 소스프로그램 작성 및 수정 -> 실행 및 검사 -> 완성

# 비쥬얼 스튜디오
vs: 파일-새로만들기-프로젝트-win32-콘솔응용프로그램-이름,위치-솔루션이름-확인
마법사: 응용프로그램설정-빈프로젝트-마침
솔루션탐색기-cpp-우클릭-추가-새항목-c++파일-이름-추가 : 소스파일에 cpp 파일 생김


```

```yaml
# 흐름제어구문
조건문: if, switch
반복문: for, while, do...while
- for:  for(초기화; 조건; 증감 ) { 문장 }
- 범위기반 for:  for( 원소선언: 데이터집합 ){ 문장 }
- while:  초기화 , while(반복조건) { 문장 ; 증감; }
- do ... while : do{ 문장 }while(조건)

# 구조체와 클래스
구조체(레코드): 여러가지 자료형의 데이터 집합을 저장할 수 있는 새로운 자료형을 정의한 것 , struct로 선언 , 중괄호 뒤에 반드시 세미콜론을 넣어야함 , c++에서는 구조체에 함수를 포함시킬수 있다
구조체형태:
struct 구조체이름 {
    자료형 멤버이름;
};
- 선언: struct 구조체이름 변수이름; 
- 구조체 초기화 : {{0,0} , 10 } 이런식으로 초기값 나열하면 된다

클래스: 행위 + 속성

# 배열과 포인터
배열: 동질자료형의 값을 연속적으로 할당한 공간(변수)
1차원배열: float array [4]
2차원배열: int array [2][3]

포인터: 변수를 가르키는 변수
포인터 예시 : int *pointer
주소값: x = &y ,   y 주소 = *x = 값

# 동적 메모리 할당
전역변수: 함수 외부에 선언된 변수 , 프로그램 시작과 종료와 함께 생성, 소멸
지역변수: 블록 내에 선언된 변수
- 자동변수: 블록에 들어갈때 생성 나갈때 소멸
- 정적변수: 프로그램 시작과 생성/소멸

동적메모리할당: 프로그램 동작중에 변수,배열,객체를 메모리에 할당하는것,포인터 변수가 할당된 기억공간을 가리키게함
기억공간 생성시점: new 연산자 실행시점
- new 연산자는 주소값을 반환한다
기억공간 소멸 시점: delete 연산자 실행시점

동적메모리 할당 연산자: ptrvar = new Typename; ptrvar = new Typename[n];
동적 메모리 반납 연산자: delete ptrvar; delete [] ptrvar;
예시: int *a = new int(5)
예시:
int *intptr
intptr = new int;
delete intptr
intptr = NULL;
예시:
int *intptr;
intptr = new int [4]
*(intptr + 1 ) = 100;
intptr[3] = 1000; 
delete[] intptr;
intptr = NULL;

```

```yaml
# 함수의 정의와 호출
함수: 프로그램 기본단위, 호출, 매개변수를 통해 함수에 데이터 전달, 처리 결과 반환, 호출한곳으로 복귀
함수장점: 중복제거, 모듈화하여 간결
함수단점: 호출과 복귀 과정 처리시간 추가됨
함수형식:
반환자료형 이름(매개변수목록)
{
    지역변수 정의
    처리할 문장
    반환문
}
- 머리부,함수원형: 반환자료형(반환안하면, void) + 이름 + 매개변수목록 
- 몸체블록: 지역변수정의, 처리할작업, 결과값 반환

# 인수의 전달
인수: 함수에 전달하는 값, 매개변수를 통해 인수를 전달함
- 실 매개변수:  값
- 형식 매개변수:  매개변수
디폴트 인수: 함수를 정의할때 인수 값을 미리 정의, 디폴트값은 생략가능 , 인수의 끝에만 위치한다


# 인수전달 방식
값 호출: 실매개 값(값 보존) -> 형식매개 값 복사
참조 호출: 실매개 참조 <-> 형식매개 전달 
- 주소를 전달하기때문에, 많은 양의 데이터로 구성되는 구조체나 객체를 인수로 전달하는 경우 효율적이다
- 참조변수: 다른 변수를 참조하는 변수 ( 포인터와 유사함 ) , 초기화를 통해서만 대상을 참조할 수 있으며, 참조 대상의 별명처럼 사용할 수 있음 , int &aref= a
- const 인수: 참조호출을 하지만, 실매개 변수의 값이 변경되는 걸 원치 않을때 const 인수 사용
- const 함수이름 &변수이름

# 함수의 다중정의
다중정의: 동일한이름을 여러개 정의하는거
함수 다중정의: 함수구분은 인수개수 , 자료형으로 한다
- 모호한경우: 디폴트 인수를 가진경우 , 형변환 대상이 모호한경우
# inline 함수
inline함수: 함수 호출 위치에 함수의 처리 문장이 삽입되어 컴파일 되는 함수. 모듈화장점, 호출시간감소, 매우 빈번히 호출되며 빠른 실행이 요구되는 경우 사용
inline함수로 번역되지 않는 경우: 함수가 너무큰경우 , 순환호출하는경우, 함수에 대한 포인터를 사용하는 경우
```

```yaml
 # 클래스와 객체
 클래스: 속성(객체의 상태 = 데이터멤버)+메소드(객체의 행위 = 멤버함수) 
 멤버함수 종류 : 
 - const 멤버함수: 데이터 멤버를 변경하지 않는 경우 const 붙여준다 , * 상수객체 - 상수 함수 만 사용가능!
 
 클래스 선언 형식:
 class classname {
     가시성 지시어_1:
     	속성 또는 함수;
     가시성 지시어_2:
     	속성 또는 함수;
 };
클래스 멤버함수선언: 클래스::멤버함수
- 자기자신을 가리키는 포인터: this

 가시성 지시어: 멤버의 공개 범위 나타냄
 - 종류: private(디폴트),public, protected
 - private 공개범위: 소속클래스-멤버함수, 친구클래스-멤버함수,친구함수 
 - public 공개범위: 전 범위
 - protected: 
 
객체 정의형식: calssname objname1, objname2,...;
객체 사용형식: objname.datamember; objname.memfuc(인수)

 # 클래스예시 ( counter 계수기 만들기 )
 계수기 정의: 행위: reset,count,getvalue 속성: int value
 - classA.h : 클래스 멤버선언
 - classA.cpp: 클래스 멤버 정의 
 - 중복 에러: include가 반복될경우 에러발생{ 조건문으로 중복 방지할수있다 }
 
 # 생성자
 생성자: 객체가 생성될때 수행할 작업 정의하는 특수한 멤버함수
 - 생성자의 이름은 클래스의 이름과 같음
 - 반환값없음, 반환자료형 표시안함
 - 생성자를 publuc으로 선언해야 클래스 외부에서 객체를 생성할 수 있음
 - 용도: 객체 초기화 , 초기화리스트 사용
 - 초기화 리스트: 생성자의 머리에 데이터 멤버를 초기화하는 값들을 나열한 리스트 ,
생성자 선언형식:
클래스이름(매개변수 리스트):초기화리스트 {}
생성자 선언 예시: counter(): value(0){}



# 소멸자
소멸자: 객체가 소멸될때 수행할 작업을 정의하는 특수한 멤버함수
- 소멸자의 이름은 클래스의 이름과 같다, 앞에 ~ 가 붙음
- 반환값없음, 반환자료형 표시않함
- 인수를 전달받을 매개변수를 포함할 수 없음 , 다중정의 불가능 
- public으로 선언하는것이 일반적
- 상속을 통해 파생클래스를 정의한느 경우 virtual 지정하여 가상함수가 되도록하는것이 좋음
- 용도: 객체가 소멸될때 수행할 작업 정의하는 특수한 멤버함수


# 생성자의 활용
디폴트 생성자: 매개변수가 없는 생성자, 또는 모든 매개변수에 디폴트 인수가 지정된 생성자 , 클래스를 선언할 때 생성자를 선언하지 않으면 컴파일러는 아무일도하지 않는 디폴트 생성자를 만듦, 생성자를 하나라도 선언하면 디폴트 생성자 자동생성 안됨
복사 생성자: 같은 클래스의 객체를 복사하여 객체를 만드는 생성자. 복사 생성자를 명시적으로 선언하지 않으면 원본 객체의 데이터 멤버들을 그대로 복사하여 객체를 정의하는 복사 생성자가 자동으로 생성됨
- 자기자신의 객체를 참조형으로 받음
- 참조받은 기억공간이 소멸할때 에러발생할수 있다, 에러없애기 위해 사용자가 직접 복사생성자 만들어서 사용한다

객체 배열의 선언: 
- 디폴트 생성자가 선언된 경우: 객체 배열을 선언할 수 있음
- 디폴트 생성자 없는 경우: 객체 배열 선언할 때 초기화 리스트를 제공해야함
객체 배열의 동적할당:
- new 연산자로 객체를 동적할당하기 위해서는 디폴트 생성자 필요

# static 데이터 멤버와 static 함수
static 데이터 멤버: 클래스에 속하는 모든 객체들이 공유하는 데이터 멤버,클래스 외부에서 별도로 정의해야함,프로그램이 시작되면 메모리공간 할당됨
static 함수 멤버: 클래스에 속하는 모든 객체들이 공유하는 함수 멤버, 일반 멤버는 사용할수 없고 static 멤버끼리 사용가능



```

```yaml

```

```c++
/* person의 클래스 명세

사람을 나타내는 클래스를 선언하고자 한다. 사람 객체는 '--- 에 사는 --- 입니다' 라고 자신을 알릴수 있고, 주소를 변경할 수 있다

< 메소드 >
- 생성자: person(char *name , char *addr )  
- 소멸자: ~person()
- 출력: void print()
- 주소변경: void chAddr (char *newAddr )

< 속성 >
이름: char *name
주소: char *addr 

*/

// Person.h
#ifndef PERSON_H_INCLUDED
#define PERSON_H_INCLUDED
class Person {
    char *name;
    char *addr;
public:
    Person(const char *name, const char *addr); // 생성자
    ~person(); // 소멸자
    void print() const; // 이름 주소 출력
    void chAddr(const char *newAddr); // 주소 변경 
};
#endif // PERSON_H_INCLUDED

// Person.cpp
#include <iostream>
#include <cstring>
#include "person.h"
using namespace std;

Person::Person(const char *name, const char *addr)
{
    this->name = new char[strlen(name)+1];
    strcpy(this->name,name);
    this->addr = new char[strlen(addr)+1];
    strcpy(this->addr, addr);
    cout << "Person 객체 생성함("<<name <<")"<<endl;
}

Person::~Person()
{
	cout << "Person 객체 제거함("<< name <<" )" << endl;
    delete [] name;
    delete [] addr;
}
void person::print() const
{
    cout << addr << "에 사는" << name <<"입니다" << endl;
}

void person::chAddr( const char *nAddr)
{
    delete [] addr; // 기존 공간 반납
    addr = new char[strlen(nAddr)+1]; // 새로운 주소에 맞는 공간 할당
    strcpy(addr,nAddr); // 데이터 멤버 addr 에 새로운 주소 복사
}

// PersonMain.cpp
#include <iostream>
#include "person.h"
using namespace std;
int main()
{
    person *p1 = new person("이철수", "서울시 종로구");
    person *p2 = new person("박은미", "강원도 동해시");
    p1->print();
    p2->print();
    cout<<endl<<"주소변경:";
    p2->chAddr("대전시 서구");
    p2->print();
    delete p1;
    delete p2;
    return 0; 
}


```

```yaml
# 연산자 다중정의
연산규칙: 연산자는 피연산자의 자료형에 따라 달란진다
연산자 다중정의: 이미 정의된 연산자를 사용자가 선언한 클래스의 객체에 대해 사용할수있도록 다중정의 하는것
주의사항: 연산자의 의미, 고유특성 유지한다
다중정의 위치: 
- 클래스 내부: 객체의 멤버를 엑세스 할수있음
- 클래스 외부: 객체의 private 멤버를 사용할수 없음

# 단항 연산자 다중정의 형식
ReturnClass CalssName::operator ++(비어있음, 후위표기법의 경우 int 넣어줌)
{
    ...
}
# 이항 연산자 다중정의 형식
규칙: 자기자신 + 형식매개변수 이런 순서로 연산한다
ReturnClass CalssName::operator opsymbol(ArgClass arg)
{
    ...
}
- friend 선언하면 private 라도 사용할수 있다 

# 배열첨자 연산자 []의 다중정의
[]연산자: 배열의 첨자를 지정하는 이항 연산자, 배열이름-첨자
예시: int& operator[](int i)

# 문자열 클래스
문자열 저장: char형 배열이나 동적 할당 메모리, 문자열 상수에 저장

# 자료형의 변환
형변환 연산자 정의 위치: 송신측클래스 or 수신측클래스
# 연산자 다중정의의 주의사항
다중정의의 대상:
- 클래스 객체간 대입 연산자: 특히 동적할당을 받는 포인터를 포함하는 경우 고려
- 수치형 객체의 산술 연산자: 교환법칙도 함께 고려함
- 두 객체를 비교하기 위한 관계연산자의 다중정의
- 스트림 입출력을 위한 >> , << 연산자
다중정의 불가능 연산자: 멤버선택 연산자, 멤버에 대한 포인터 연산자, 유효범위 결정 연산자, 조건 연산자




```

```yaml
# 기초 클래스
기초클래스:

# 파생 클래스
파생클래스 형식:
class DClassName : visibilityspec BClasssName{
    가시성지시어1:
    	멤버들;
    가시성지시어2:
    	멤버들;
    	...
};
- DClassName : 파생 클래스 이름
- BClassName : 기초 클래스 이름
- visibilityspec: 가시성 지시어


# 클래스 계층
트리구조: 트리구조형태
그래프 구조: 그래프 형태

# 파생 클래스의 생성자 및 소멸자
파생클래스 생성자 선언형식:
DClassName(dArgsList): BClassName(bArgsList)
{
    ....// 파생클래스 생성자에서 추가되는 사항
}
- DClassName:  파생클래스 생성자
- BClassName: 기초클래스 생성자
- dArgsList: 파생클래스 생성자 인수 목록
- bArgsList: 기초 클래스 생성자에 전달할 인수 목록

생성자 및 소멸자 실행 순서: 기초 생성 -> 파생 생성 -> 파생 소멸 -> 기초 소멸

# 엑세스 제어
가시성 지시어:
- private: 소속,친구
- protected: 소속,친구,파생,파생친구
- publuc: 전범위
가시성의 상속: 상한으로 상속된다

# 상속과 포인터


# 가상함수
정적연결: 객체 포인터에의해 멤버함수를 호출할 경우 컴파일러가 포인터의 유형에 따라 호출할 멤버함수를 결정함
동적연결: 객체 포인터를 통해 객체 멤버함수를 호출할 경우 포인터가 가리키는 실제 객체가 무엇인가에 따라 실행중에 멤버함수를 결정하는 방법, c++에서는 가상함수로 동적 연결을 구현함, 기초클래스에서 가상함수로 선언한 멤버함수를 파생클래스에서 재정의 하면 가상함수로 선언하지 않아도 가상함수임

소멸자의 동적연결: <기초클래스의 포인터에 연결된 파생클래스 객체를 제거 할때 기초 클래스의 소멸자만 동장하는 문제를 해결하기 위해 > 소멸자를 가상함수로 선언하여 파생클래스에서도 소멸자가 동작하도록 함

업캐스팅: 파생클래스 포인터를 기초클래스 포인터로 변환하는 것, 자동 형 변환을 통해 업 캐스팅 할 수 있음
다운 캐스팅: 기초클래스 포인터를 파생클래스 포인터로 변환하는것, 자동형 변환 불가, 형변환 연산자를 통해 명시적으로 변환 해야함, ex) dynamic_cast<객체형> , 가상함수를 포함한 클래스만 사용가능하다

# 추상클래스
추상클래스: 유사한 성격을 갖는 클래스들의 공통적 요소들을 뽑아서 만든 클래스 , 일부 메소드의 구체적 구현이 없어 직접적인 사례가 존재하지 않는 클래스 , 추상클래스로 객체를 직접 정의할수 없음
- 선언: 멤버함수중 순수가상함수가 포함된 클래스를 선언
- 순수가상함수: 구현 부분이 없는 가상함수
- 순수 가상함수 선언: virtual RetType functioName(fparmeterlist) = 0;

상세클래스: 직접적으로 객체 정의 가능
- 선언: 순수가상함수를 포함하지 않는 클래스, 상속된 순수가상함수가 있을경우 구체적으로 구현해야함


# 다중상속
다중상속: 2개이상의 기초 클래스로부터 상속을 받는것
- 모호성 해결: 기초클래스::함수() 이런식으로 소속을 명확히 표현한다
- 중복 상속 해결: 가상 기초 클래스로 상속 , 가상기초클래스로 상속된 경우는 상속된 생성자를 명시해야한다

```

```yaml

# 컨테이너 클래스와 템플릿
컨테이너 클래스: 다른객체를 저장하는 클래스
템플릿: 클래스 , 함수 등을 선언하기 위한 형판
- 자료형 , 상수 등을 인수를 통해 전달 받음
- 여러가지 대상을 위한 클래스나 함수를 템플릿으로 선언함으로써 , 동일한 코드를 반복적으로 작성하는것을 방지함

# 스택 템플릿
클래스 템플릿 선언 방식:
template<class x>
class classtemplateName {
    ... 
}

클래스 템플릿의 객체 정의 형식:
classTemplateName<ClassNames=템플릿 매개변수에 전달할 인수>
	objname(constArgs=생성자에 전달할 인수);

탬플릿 인수: 템플릿 매개변수를 통해 전달할 수 있는 인수
- 클래스 이름 외에도 함수 이름이나 상수를 전달할 수 있음

# 리스트 템플릿
연결리스트: 데이터를 저장하는 노드를 포인터를 이용하여 순차적으로 연결되어 있는 데이터 구조

# 함수 템플릿
함수템플릿 선언 형식: 
template<templatearg>
returntype funcTemplateName(fparameterlist){
    ...
}
정렬알고리즘: 데이터를 순서에 따라 배치하는 알고리즘
- 버블정렬: 인접한 데이터 비교하여 정렬
# 표준 템플릿 라이브러리
표준템플릿라이브러리(stl): c++에서 제공되는 표준 컨테이너 클래스 템플릿 라이브러리, 벡터,리스트,스택,큐등의 컨테이너와 이들을 처리하기 위해 사용할수 있는 여러 연산을 포함함
- 컨테이너 : 데이터 저장
- 반복자 : 포인터 역할
- 알고리즘: 데이터 처리기능

컨테이너: int나 floa 과 같은 기본 자료형 데이터나 사용자 정의 클래스의 객체 등 저장함 
- 다양한 연산이 제공되어 편리하게 데이터 저장할수 있음
- 배열역시 일종의 컨테이너 역할을 하나 배열을 조작하기 위한 연산( 특정 위치에 데이터 삽입, 데이터 삭제등)을 프로그래머가 모두 구현해야함
- 컨테이너 종류: 순차 컨테이너 , 연상 컨테이너

순차컨테이너: 동일한 자료형의 객체들을 선형구조로 저장함
- 벡터: 확장가능배열, 첨자를 이용한 접근, 끝에 삽입/삭제는 빠르나 , 그외 위치는 처리느림
- 리스트: 이중연결리스트, 어느 위치에든 삽입이 효율적임, 직접접근이 어려움
- 큐: 벡터와 동일하나, 앞에서도 효율적으로 삽입할수 있음
연상컨테이너: 키를 이용한 검색 기능을 제공함
- 셋: 키 객체만 저장함, 키 값이 중복되지 않음
- 멀티셋: 키 객체만 저장함, 키 값 중복 가능
- 맵: 키 객체를 값 객체와 연결하여 저장, 키 값이 중복되지 않음
- 멀티맵: 키 객체를 값 객체와 연결하여 저장, 동일한 키 값이 중복될 수 있음

반복자: 포인터의 개념이 일반화 된것, 컨테이너의 유형에 따라 서로 다른 형태의 반복자 사용됨
- 순방향 반복자:  ++ 연산자 사용
- 양방향 반복자: ++ , -- 사용
- 랜덤 액세스 반복자: 양방향 반복자의 기능과 함께 임의의 위치로 이동할 수 있음

알고리즘: 컨테이너의 반복자가 인수로 전달되어 그 알고리즘이 어떤 객체 또는 범위에 대해 동작할 것인지를 지정함
# 벡터 클래스 템플릿
벡터클래스 템플릿 :
- 배열의 개념을 구현한 클래스 템플릿
- 일반적인 배열의 기능을 포함하면서 여러가지 유용한 멤버함수 및 관리 기능이 도입되어 있음
- 헤더파일 <vector> 를 include 명령으로 프로그램에 삽입함
vector객체의 선언 구문: vector<className> objName(n); 
- n: 벡터에 저장할 객체의 수
벡터의 크기: 배열과 같이 크기를 정하여 생성되나, 필요에 따라 크기를 확장할 수 있음
관련 멤버함수:
- size: 논리적 크기 반환
- capacity: 벡터의 실제 크기 반환
- resize: 벡터의 크기를 n으로 변경함
- reserve: capacity가 최소한 n을 반환하도록 함
- push_back: 벡터의 끝에 저장 공간을 확장하여 value를 저장함 
- pop_back: 벡터의 마지막 원소를 제거함 
논리적 크기: 논리적으로 지정된 크기 ( 물리적 크기와는 다르다 )


반복자의 선언: vector<classname>::iterator it;
- 관련멤버함수:
 - begin: 첫 번째 원소를 나타내는 랜덤 액세스 반복자 반환함
 - end: 마지막 원소의 다음 위치를 가리키는 랜덤 액세스 반복자를 반환함

알고리즘: 반복자를 사용하여 컨테이너의 원소에 대해 적용할 수 있는 연산을 제공함
- include 명령으로 헤더파일 <algorithm> 을 소스 프로그램에 삽입한 후 알고리즘의 함수를 사용함
- 알고리즘 예: sort, merge 
```

```yaml
# 예외 유형
예외란: 프로그램 실행 도중에 비정상적인 상황이 발생하는것
- 예외 예시: 사용자의 입력오류, 계산불능경우, 자원할당할수없는 경우

# c++ 언어의 예외처리 체계
try블록:
catch블록:
throw블록:

# 예외처리 클래스
예외처리 클래스의 활용: 클래스 설계시 예외처리 기능을 포함시킴으로써 객체에서 예외가 발생하였을때 그 위치나 원인 등의 식별을 용이하게 할 수 있음 , 클래스 선언문 내에 예외처리 담당클래스를 선언하여 활용함

exception 클래스: 예외처리 담당 클래스의 기초 클래스로 제공하는 클래스
- 헤더파일 <exception> 을 소스파일에 포함시킴
- 가상함수 what()을 멤버함수로 가지고 있음
- 예외의 종류를 char* 형태로 반환함
- exception의 파생 클래스에서 재정의하여 사용함

```

```yaml

```

```yaml

```

```yaml

```

```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml
5
```

