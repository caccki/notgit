```yaml
# 자료구조
자료: 값, 사실
정보: 처리된 자료
자료와 정보 관계: 정보 = 처리(자료)
자료구조의 개념: 자료를 논리적 관계로 구조화한것

자료구조: 입력값의 추상화
알고리즘: 수행해야할 명령의 추상화

P(D,A) = I
프로그램 ( 자료구조 , 알고리즘 ) = 처리된 자료


자료구조:
- 사용자 정의 : 리스트, 스택, 큐, 트리, 그래프
- 기본정의 : 기본자료(정수,실수,문자)  , 파생된자료(배열,구조체,포인터)

# 알고리즘
알고리즘: 명령어의 유한집합이 추상화된것
- 입력: 넣어야한다
- 출력 : 나와야한다
- 유효성 : 일정해야한다
- 명확성 : 명확해야한다
- 유한성 : 끝나야한다

알고리즘 성능 분석과 측정: cpu , 메모리 관점에서 효율성 측정
- 실행시간 분석: 알고리즘의 실행 횟수를 O(n)이라고 표현, 같은 O(n)을 가진다고 해서 같은 실행시간을 갖는것이 아니라 유사항 증가 경향을 보임
- 실행 메모리 분석: 공간복잡도(Sp) = 고정공간(Sc) + 가변공간(Se)
- 성능측정: 시스템 시계를 이용해서 실제 시간 측정

```

```yaml
# 배열의 정의
배열: <위치:값> 쌍의 집합
- 배열의 위치(추상화된값)는 메모리공간의 물리적인(구체화된 값) 순서와 같다 , 직접접근 가능
# 배열의 추상 자료형(교재24p)
ADT array : < index(순서) , Element(원소) > 
# 1차원 배열
1차원배열: 인덱스 1종류
# 배열의 확장
2차월배열: 
- 행우선: 행단위로 끊음
- 열우선: 열단위로 끊음
- 행우선, 열우선은 언어에 따라 다르다, 언어에 맞게 프로그램 짜야 효율적이다

# 희소행렬 개념
희소행렬: 반복되는부분은 없애고 저장한다
(행,열,값) : 의 형태로 저장한다
```

```yaml
스택의 정의(44p) :
- 0개이상의 원소를 갖는 유한 순서 리스트
- push,pop 연산 가지는 자료구조
- 객체와 그 객체가 저장되는 순서를 기억하는 방법에 관한 추상자료형

# 스택의 응용과 연산
스택의 응용:
- 변수에 대한 메모리 할당과 수집을 위한 시스템 스택 (os)
- 서브루틴 호출 관리를 위한 스택 ( pl )
- 연산자들 간의 우선순위에 의해 계산 순서가 결정되는 수식 계산 ( ds, aglo)
- 인터럽트 처리와 이후 리턴 할 명령 수행 지점을 저장하기 위한 스택( pl )
- 컴파일러, 순한 호출 관리

# 배열을 이용한 스택의 구현(52p)

# 사칙 연산식의 전위/후위/중위 표현
```

```yaml
# 큐의 개념및 추상자료형
큐: add- rear / front -delete
- full , emty 검사 
- delete, add 연산
# 큐의 응용
FCFS 스케쥴링 기법: cpu에 큐를 이용해 순차적으로 작업할당
# 배열을 이용한 큐의 구현
# 원형 큐
원형큐: 배열의 문제점을 해결하기 위해 원형 큐가 제안됨 , 일반적으로 앞-뒤 한칸 띄어놓는다
- 배열의 문제점: 더 넣을 공간이 없어서 full이 되버림 , 원형으로 만들면 더 넣을수 있다
```

```yaml
# 리스트의 개념
리스트: 의미적, 논리적 순서 ( 물리적 위치나 순서는 중요하지 않다 )
- 배열을 이용한 리스트구현: 거의 사용안함 , 확장성에 문제가 생긴다
- 포인터를 이용한 리스트구현(연결리스트) :  원소값-위치정보저장공간 함께 구현

# 포인터를 이용한 리스트의 구현
노드의 구조: 리스트의 원소(값) + 다음 원소를 가리키는 정보
- 노드는 데이터요소(원소,값)와 리스트의 다음원소를 지싷하는 포인터(주소,링크)로 구성됨
- # 연결 리스트의 원소 삽입/삭제
리스트의 생성: data-link 노드 생성 , 
포인터 할당/반환: 할당(malloc) , 반환(free)
- # 연결 리스트에서 노드의 삽입/삭제
연결리스트에서 노드 삭제: 링크를 끊고 다른곳에 연결하면, 끊긴 노드는 삭제된것으로 간주된다, 삭제된것은 free로 반환
연결리스트에서 노드 삽입: 링크를 연결한다


# 연결리스트의 변형
단순연결리스트: 링크부분 하나, 한방향
이중연결리스트: 링크부분 두개 , 양방향
원형연결리스트: 마지막노드의 null값을 활용해
```

```yaml
# 트리
트리특징: 검색의 편리함 , 논리적 계층, 계급적 특성
트리구성:
- 노드: 트리의 항목: 트리에 저장되는 데이터의 묶음
- 부모노드-자식노드: 상하 계층 구조가 있고 직접적으로 연결된 노드로서 상위계층의 부모노드와 하위계층의 자식노드
- 루트노드: 최상위 노드 , 진입차수=0
- 서브트리: 부모노드를 삭제하면 생기는 트리들
- 리프노드: 트리의 맨 끝에 있으면서 , 자신의 서브트리를 갖지 않는 노드 , 진출차수=0
트리레벨:
- 노드의 레벨: 루트부터 잎까지의 깊이

# 이진트리
이진트리: 모든 노드의 진출차수가 2이하인 트리
- 구현도 쉽고, 수학적 표현도 쉽다 , 오른쪽-왼쪽 방향의 개념 가진다
완전이진트리: 꽉찬 이진트리
포화 이진트리: 꽉찬 이진트리 + 잎(왼쪽부터 채움)

# 이진트리 구현
배열으로 구현: 완전, 포화 이진트리 경우 낭비없어서 효율적 , 그렇지 않을 경우 매우 비효율
포인터로 구현: 배열로 비효율적인 경우, 포인터로 구현하는게 효율적

# 이진트리 순회
전위순회:  P L R 
중위순회: L P R
후위순회: L R P

# 순회 알고리즘
노드갯수세기, 잎 갯수 세기,일반트리를 이진 트리로 변환 등등 이해하기

```

```yaml
# 스레드 트리의 정의
스레드 트리정의: '스레드' 라는 포인터를 추가하여 트리 순회를 편리하게 한것
- 이진트리의 노드를 순회할때, 방문하지 않고 지나쳐온 노드들을 재귀호출하여 스택에 저장하여 관리해야하는 번거로움을 해결하기 위함
- 삽입과 삭제가 많은경우는 사용하지 않는게 좋다.

# 스레드 트리 구현 방법(1)
포인터 필드의 추가: 스레드를 저장하는 포인터를 추가하는것 ,  *좌스레드-좌-값-우-*우스레드
# 스레드 트리 구현 방법(2)
잎 노드의 빈 포인터를 활용: 잎노드에 있는 빈포인터를 사용 , *좌 - 값 - *우
- 노드갯수 : n
- 전체 포인터 갯수 :  2n 
- 활용하는 포인터 갯수 : n-1
- 빈 포이터 갯수 : 2n - ( n-1 ) = n+1개

# 스레드 트리의 연산(순회,삽입,삭제)


```

```yaml
# 힢
힢: 피라미드 모양 더미 , 가장위의것을 꺼냄 , 부모-자식 포화이진트리
큐: 먼저줄서면 먼저서비스
- 우선순위큐: 조건에 따른 처리 구조 , 우선순위 큐의 문제점보다 해결위해 힢등장

힢의 추상자료형:
힢 객체 정의: 부분적으로 정렬된 포화이진트리로 부모노드는 자식노드보다 우선순위가 높다
연산:
- insert : 힢에 데이터 삽입
- remove: 힢(루트)에서 데이터 삭제 , 모양변경
- peek: 힢(루트)에서 데이터 읽어오기 , 모양유지
- isEmpty : 힢이 비었는지 확인
- size: 힢에 저장한 데이터 개수 확인

# 힢종류
최소힢: 루트가 최소값을 가짐 , 완전이진트리
최대힢 : 루트가 최대값 

# 힢 노드의 삭제 및 삽입
힢 구현을 위한 자료구조: 완전이진트리이기 때문에 배열로 구현해도 기억장소 낭비가 적음
- 연결리스트보다 실행 속도 면에서 효율적임
- 기억장소 측면에서도 장점을 가짐
- 자식노드 방번호 : *2 , *2+1 

# 더이상의 설명은 생략, 책보자 ㅠ

```

```yaml
# 선택트리
선택트리 : 비교횟수를 줄여주는 목적
- 합병정렬: 서로 다른걸 합병하면서 정렬함
- 승자트리: 부모가 작은값을 갖는 포화 이진트리
- 패자트리: 루트위에 0 넣음, 부모가 패자저장 (큰값), 비교할 값은 올라간다

# 숲
숲: 0개 이상의 트리집합
- 트리에서 루트를 제거하고 남은것이 숲
- 숲을 연결하면 트리
```

```yaml

```

```yaml

```

```yaml

```

```yaml

```

```yaml

```

```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml


```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```
```yaml

```

